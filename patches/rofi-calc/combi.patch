diff --git a/src/calc.c b/src/calc.c
index 80b7937..93e9067 100644
--- a/src/calc.c
+++ b/src/calc.c
@@ -59,6 +59,7 @@ typedef struct {
     char *calc_error_color;
     char *last_result;
     char *previous_input;
+    char *preprocessed_input; // Input that was preprocessed (for standalone mode detection)
     GPtrArray *history;
     CALCModeConfig config;
 } CALCModePrivateData;
@@ -415,6 +416,7 @@ static void get_calc(Mode *sw) {
     pd->last_result = g_strdup("");
     pd->history = g_ptr_array_new();
     pd->previous_input = g_strdup(""); // providing initial value
+    pd->preprocessed_input = g_strdup(""); // Track which input was preprocessed
 
     set_config(sw);
 
@@ -669,6 +671,10 @@ static void calc_mode_destroy(Mode *sw) {
     }
 }
 
+// Forward declarations
+static void compute_result(const Mode *sw, const char *input);
+extern void rofi_view_reload(void);
+
 static char *calc_get_display_value(const Mode *sw, unsigned int selected_line,
                                     G_GNUC_UNUSED int *state,
                                     G_GNUC_UNUSED GList **attr_list,
@@ -680,33 +686,128 @@ static char *calc_get_display_value(const Mode *sw, unsigned int selected_line,
     }
 
     if (selected_line == 0) {
-        if (!pd->config.no_history)
-            return g_strdup("Add to history");
-        else
+        if (!pd->config.no_history) {
+            // Check if we're in standalone mode (preprocess_input was called for current input)
+            gboolean is_standalone = (strcmp(pd->previous_input, pd->preprocessed_input) == 0);
+
+            // In combi mode, show result in first line (preprocess_input not called)
+            // In standalone mode, show "Add to history" (result is in message widget)
+            if (!is_standalone && pd->last_result && *pd->last_result) {
+                // Combi mode: show result in first line
+                if (is_error_string(pd->last_result)) {
+                    return g_strdup_printf("%s", pd->last_result);
+                } else {
+                    return g_strdup_printf("%s%s", pd->hint_result, pd->last_result);
+                }
+            } else {
+                // Standalone mode: show "Add to history" (result is in message widget)
+                return g_strdup("Add to history");
+            }
+        } else {
             return g_strdup("");
+        }
     }
     unsigned int real_index =
         get_real_history_index(pd->history, selected_line);
     return g_strdup(g_ptr_array_index(pd->history, real_index));
 }
 
-static int calc_token_match(G_GNUC_UNUSED const Mode *sw,
-                            G_GNUC_UNUSED rofi_int_matcher **tokens,
+// Helper to unescape regex patterns back to original input
+static char* unescape_regex_pattern(const char *pattern) {
+    GString *result = g_string_new("");
+    const char *p = pattern;
+
+    while (*p) {
+        if (*p == '\\' && *(p + 1)) {
+            // Skip the backslash and add the next character
+            p++;
+            g_string_append_c(result, *p);
+        } else {
+            g_string_append_c(result, *p);
+        }
+        p++;
+    }
+
+    return g_string_free(result, FALSE);
+}
+
+static int calc_token_match(const Mode *sw,
+                            rofi_int_matcher **tokens,
                             G_GNUC_UNUSED unsigned int index) {
+    CALCModePrivateData *pd = (CALCModePrivateData *)mode_get_private_data(sw);
+
+    // Clear preprocessed_input to mark we're in combi mode
+    if (pd->preprocessed_input && *pd->preprocessed_input) {
+        g_free(pd->preprocessed_input);
+        pd->preprocessed_input = g_strdup("");
+    }
+
+    // Try to reconstruct input from tokens for combi mode
+    if (tokens && tokens[0]) {
+        GString *input_str = g_string_new("");
+        for (int i = 0; tokens[i] != NULL; i++) {
+            if (i > 0) {
+                g_string_append_c(input_str, ' ');
+            }
+            const char *pattern = g_regex_get_pattern(tokens[i]->regex);
+            char *unescaped = unescape_regex_pattern(pattern);
+            g_string_append(input_str, unescaped);
+            g_free(unescaped);
+        }
+
+        char *reconstructed = g_string_free(input_str, FALSE);
+
+        // Check if input changed and compute result
+        if (strcmp(reconstructed, pd->previous_input) != 0) {
+            g_free(pd->previous_input);
+            pd->previous_input = g_strdup(reconstructed);
+            compute_result(sw, reconstructed);
+        }
+        g_free(reconstructed);
+    }
+
     return TRUE;
 }
 
-// It's a hacky way of making rofi show new window titles.
-extern void rofi_view_reload(void);
-
-static void process_cb(GObject *source_object, GAsyncResult *res,
-                       gpointer user_data) {
+// Helper function to compute result for given input
+static void compute_result(const Mode *sw, const char *input) {
     GError *error = NULL;
-    GSubprocess *process = (GSubprocess *)source_object;
-    GInputStream *stdout_stream = g_subprocess_get_stdout_pipe(process);
-    char **last_result = (char **)user_data;
+    CALCModePrivateData *pd = (CALCModePrivateData *)mode_get_private_data(sw);
+
+    char *qalc_binary = "qalc";
+    if (find_arg(QALC_BINARY_OPTION) >= 0) {
+        find_arg_str(QALC_BINARY_OPTION, &qalc_binary);
+    }
+
+    // Build array of strings that is later fed into a subprocess to actually
+    // start qalc with proper parameters.
+    GPtrArray *argv = g_ptr_array_new();
+    g_ptr_array_add(argv, qalc_binary);
+    g_ptr_array_add(argv, "-s");
+    g_ptr_array_add(argv, "update_exchange_rates 1days");
+    if (pd->config.terse) {
+        g_ptr_array_add(argv, "-t");
+    }
+    if (!pd->config.no_unicode) {
+        g_ptr_array_add(argv, "+u8");
+    }
+    g_ptr_array_add(argv, (gchar *)input);
+    g_ptr_array_add(argv, NULL);
 
-    g_subprocess_wait_check_finish(process, res, &error);
+    GSubprocess *process = g_subprocess_newv(
+        (const gchar **)(argv->pdata),
+        G_SUBPROCESS_FLAGS_STDOUT_PIPE | G_SUBPROCESS_FLAGS_STDERR_MERGE,
+        &error);
+    g_ptr_array_free(argv, TRUE);
+
+    if (error != NULL) {
+        g_error("Spawning child failed: %s", error->message);
+        g_error_free(error);
+        return;
+    }
+
+    // Wait synchronously for the result to make it work in combi mode
+    g_subprocess_wait_check(process, NULL, &error);
 
     if (error != NULL) {
         // With qalculate >= 5.0.0, exit status 1 can mean bad (or
@@ -718,6 +819,8 @@ static void process_cb(GObject *source_object, GAsyncResult *res,
         error = NULL;
     }
 
+    // Read the output
+    GInputStream *stdout_stream = g_subprocess_get_stdout_pipe(process);
     gsize bytes_read = 0;
     unsigned int stdout_bufsize = 4096;
     char stdout_buf[stdout_bufsize];
@@ -730,7 +833,11 @@ static void process_cb(GObject *source_object, GAsyncResult *res,
         error = NULL;
     }
 
-    *last_result = g_strndup(stdout_buf, bytes_read - 1);
+    if (bytes_read > 0) {
+        g_free(pd->last_result);
+        pd->last_result = g_strndup(stdout_buf, bytes_read - 1);
+    }
+
     g_input_stream_close(stdout_stream, NULL, &error);
 
     if (error != NULL) {
@@ -739,13 +846,16 @@ static void process_cb(GObject *source_object, GAsyncResult *res,
         error = NULL;
     }
 
-    rofi_view_reload();
+    g_object_unref(process);
 }
 
 static char *calc_preprocess_input(Mode *sw, const char *input) {
-    GError *error = NULL;
     CALCModePrivateData *pd = (CALCModePrivateData *)mode_get_private_data(sw);
 
+    // Save this input as preprocessed (marks standalone mode)
+    g_free(pd->preprocessed_input);
+    pd->preprocessed_input = g_strdup(input);
+
     if (strcmp(input, pd->previous_input) == 0) {
         return g_strdup(pd->previous_input);
     }
@@ -753,39 +863,10 @@ static char *calc_preprocess_input(Mode *sw, const char *input) {
     g_free(pd->previous_input);
     pd->previous_input = g_strdup(input);
 
-    char *qalc_binary = "qalc";
-    if (find_arg(QALC_BINARY_OPTION) >= 0) {
-        find_arg_str(QALC_BINARY_OPTION, &qalc_binary);
-    }
+    compute_result(sw, input);
 
-    // Build array of strings that is later fed into a subprocess to actually
-    // start qalc with proper parameters.
-    GPtrArray *argv = g_ptr_array_new();
-    g_ptr_array_add(argv, qalc_binary);
-    g_ptr_array_add(argv, "-s");
-    g_ptr_array_add(argv, "update_exchange_rates 1days");
-    if (pd->config.terse) {
-        g_ptr_array_add(argv, "-t");
-    }
-    if (!pd->config.no_unicode) {
-        g_ptr_array_add(argv, "+u8");
-    }
-    g_ptr_array_add(argv, (gchar *)input);
-    g_ptr_array_add(argv, NULL);
-
-    GSubprocess *process = g_subprocess_newv(
-        (const gchar **)(argv->pdata),
-        G_SUBPROCESS_FLAGS_STDOUT_PIPE | G_SUBPROCESS_FLAGS_STDERR_MERGE,
-        &error);
-    g_ptr_array_free(argv, TRUE);
-
-    if (error != NULL) {
-        g_error("Spawning child failed: %s", error->message);
-        g_error_free(error);
-    }
-
-    g_subprocess_wait_check_async(process, NULL, process_cb,
-                                  (gpointer)&pd->last_result);
+    // Reload view to update message widget in standalone mode
+    rofi_view_reload();
 
     return g_strdup(input);
 }
